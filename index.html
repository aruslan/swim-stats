<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swim Stats</title>
  <meta name="viewport" content="width=400, initial-scale=1">
  <style>
    body {
      background: #000;
      color: #fff;
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
    }
    .container {
      display: flex;
      flex-direction: row;
      margin: 30px 0;
      background: #111;
      border-radius: 20px;
      box-shadow: 0 4px 20px #000a;
      overflow: hidden;
      min-width: 420px;
    }
    .left {
      padding: 24px 0 24px 24px;
    }
    .table {
      border-collapse: collapse;
      min-width: 280px;
    }
    .table th, .table td {
      font-size: 15px;
      padding: 2px 8px;
      text-align: right;
    }
    .table th { color: #aaa; font-weight: 600;}
    .official { color: #fff; font-weight: bold;}
    .unofficial { color: #aaa; font-weight: bold;}
    .level-cell {
      width: 26px;
      text-align: center;
      padding-left: 0; padding-right: 0;
    }
    .level-bb {
      color: #39c570;
      font-weight: bold;
      font-size: 15px;
    }
    .level-b {
      color: #39c570;
      font-weight: bold;
      font-size: 15px;
    }
    .delta-good { color: #39c570; }
    .delta-bad { color: #ff3333; }
    .delta-empty { color: #fff;}
    .right {
      background: #000;
      padding: 24px 24px 24px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 80px;
      border-left: 2px solid #222;
    }
    .name-btn {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 1px;
      margin-bottom: 24px;
      margin-top: 6px;
      text-align: center;
      background: none;
      border: none;
      color: #fff;
      width: 60px;
      padding: 8px 0;
      cursor: pointer;
      border-radius: 8px;
      transition: background .1s;
    }
    .name-btn:hover, .name-btn:focus {
      background: #232;
      outline: none;
    }
    .stroke-btn {
      display: block;
      width: 60px;
      margin: 3px 0;
      padding: 5px 0;
      border: none;
      border-radius: 9px;
      background: none;
      color: #aaa;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background .12s, color .12s;
      text-align: center;
    }
    .stroke-btn.active {
      background: #39c570;
      color: #fff;
    }
    .stroke-btn:focus { outline: none; }
    .delta-btn {
      all: unset;
      cursor: pointer;
      color: #aaa;
      font-size: 15px;
      padding: 0 6px;
      border-radius: 5px;
      transition: background .1s;
    }
    .delta-btn:hover, .delta-btn:focus {
      background: #232;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="left">
    <table class="table" id="statsTable">
      <thead>
        <tr>
          <th>Event</th>
          <th>Time</th>
          <th class="level-cell"></th>
          <th>
            <button id="deltaModeBtn" class="delta-btn" title="Switch mode">Δ</button>
          </th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div class="right" id="strokesCol">
    <!-- Buttons and name will be injected here -->
  </div>
</div>
<script>
const SWIMMERS = {
  "AA": {name:"Anna Abdikeeva"},
  "VD": {name:"Valerie Dronova"},
  "IR": {name:"Imari Racine"}
};
const SWIMMER_KEYS = Object.keys(SWIMMERS);
let swimmerIndex = 0;
let swimmerKey = SWIMMER_KEYS[swimmerIndex];
let swimmerName = SWIMMERS[swimmerKey].name;

const STROKES = ["BR", "FR", "FL", "BK", "IM"];
const STROKE_LABELS = {
  "FR":"Freestyle",
  "BK":"Backstroke",
  "BR":"Breaststroke",
  "FL":"Butterfly",
  "IM":"IM"
};
const STROKE_BTN_LABELS = {
  "FR":"Free", "BK":"Back", "BR":"Breast", "FL":"Fly", "IM":"IM"
};

const TIMES_URL = "./times.json";
const UNOFFICIAL_URL = "./unofficial_times.json";
const B_URL = "./b_times_11_12.json";
const BB_URL = "./bb_times_11_12.json";

let bTimes = {}, bbTimes = {}, allOfficialTimes = [], allUnofficialTimes = [];
let officialTimes = [], unofficialTimes = [];
let deltaMode = "accomplishments";
let currentStroke = STROKES[0];

function parseTime(s) {
  if (!s) return Infinity;
  s = String(s);
  if (s.includes(':')) {
    let [m,sec] = s.split(':');
    return parseInt(m)*60 + parseFloat(sec);
  }
  return parseFloat(s);
}
function fmt(s) { return s || "—"; }
function parseSec(s) { return parseTime(s); }

async function fetchAllData() {
  const [times, unofficial, b, bb] = await Promise.all([
    fetch(TIMES_URL).then(r=>r.json()),
    fetch(UNOFFICIAL_URL).then(r=>r.json()),
    fetch(B_URL).then(r=>r.json()),
    fetch(BB_URL).then(r=>r.json())
  ]);
  bTimes = b;
  bbTimes = bb;
  allOfficialTimes = times;
  allUnofficialTimes = unofficial;
  setSwimmer(swimmerIndex);
}

function setSwimmer(index) {
  swimmerIndex = index;
  swimmerKey = SWIMMER_KEYS[swimmerIndex];
  swimmerName = SWIMMERS[swimmerKey].name;
  officialTimes = allOfficialTimes.filter(r => r.name === swimmerName).map(r=>({...r, unofficial:false}));
  unofficialTimes = allUnofficialTimes.filter(r => r.name === swimmerName).map(r=>({...r, unofficial:true}));
}

function getStandards(strokeFull, fmtType, ev) {
  return {
    b: bTimes[strokeFull]?.[fmtType]?.[String(ev)] || null,
    bb: bbTimes[strokeFull]?.[fmtType]?.[String(ev)] || null
  };
}

// Helper: get the list of event distances per stroke & format, in your desired order
function getEventList(strokeFull, fmtType) {
  if (strokeFull === "Freestyle") {
    if (fmtType === "SCY") return [50,100,200,500,1000,1650];
    if (fmtType === "LCM") return [50,100,200,400,800,1500];
  }
  if (strokeFull === "Backstroke" || strokeFull === "Breaststroke" || strokeFull === "Butterfly") {
    return [50,100,200];
  }
  if (strokeFull === "IM") {
    if (fmtType === "SCY") return [100,200,400];
    if (fmtType === "LCM") return [200,400];
  }
  return [];
}

function renderTable(strokeCode) {
  const strokeFull = STROKE_LABELS[strokeCode];
  let rows = '';
  // Order: LCM first, SCY second
  const FORMATS_ORDERED = ["LCM", "SCY"];
  for (let fmtType of FORMATS_ORDERED) {
    const evList = getEventList(strokeFull, fmtType);
    for (let ev of evList) {
      const {b, bb} = getStandards(strokeFull, fmtType, ev);
      if (b == null) continue; // Only show events with B standard
      const eventKey = `${ev} ${strokeCode} ${fmtType}`;
      const times = officialTimes.concat(unofficialTimes).filter(r=>r.event === eventKey);
      let timeVal = '', timeSec = Infinity, candidate = null, levelHTML = '';
      if (times.length) {
        candidate = times.sort((a,b)=>parseSec(a.time)-parseSec(b.time))[0];
        timeVal = candidate.time;
        timeSec = parseSec(timeVal);
      }
      const bSec = b ? parseSec(b) : Infinity;
      const bbSec = bb ? parseSec(bb) : Infinity;
      const timeClass = candidate && candidate.unofficial ? 'unofficial' : 'official';

      // Level column logic
      if (timeSec <= bbSec && bb) {
        levelHTML = `<span class="level-bb">BB</span>`;
      } else if (timeSec <= bSec && b) {
        levelHTML = `<span class="level-b">B</span>`;
      } else {
        levelHTML = "";
      }

      // Delta column logic
      let delta = '', deltaClass = 'delta-empty';
      if (!timeVal) {
        delta = '';
      } else if (deltaMode === "accomplishments") {
        if (timeSec > bSec) {
          delta = "+" + (timeSec - bSec).toFixed(2);
          deltaClass = "delta-bad";
        } else if (timeSec > bbSec) {
          delta = "B " + (timeSec - bSec).toFixed(2);
          deltaClass = "delta-good";
        } else {
          delta = "BB " + (timeSec - bbSec).toFixed(2);
          deltaClass = "delta-good";
        }
      } else {
        // targets mode: only show closest "to next" (do NOT show multi deltas)
        if (timeSec > bSec) {
          delta = (timeSec - bSec).toFixed(2) + " to B";
        } else if (timeSec > bbSec) {
          delta = (timeSec - bbSec).toFixed(2) + " to BB";
        } else {
          delta = ""; // Already BB or better, nothing to show
        }
        deltaClass = "";
      }
      rows += `<tr>
        <td>${ev} ${fmtType}</td>
        <td class="${timeClass}">${fmt(timeVal)}</td>
        <td class="level-cell">${levelHTML}</td>
        <td class="${deltaClass}">${delta}</td>
      </tr>`;
    }
  }
  document.querySelector('#statsTable tbody').innerHTML = rows;
}

function renderStrokes(currentStroke) {
  const col = document.getElementById('strokesCol');
  col.innerHTML = '';
  // Name as a button
  const nameBtn = document.createElement('button');
  nameBtn.className = 'name-btn';
  nameBtn.innerText = SWIMMERS[swimmerKey].name.split(' ')[0];
  nameBtn.onclick = () => {
    const nextIndex = (swimmerIndex + 1) % SWIMMER_KEYS.length;
    setSwimmer(nextIndex);
    renderTable(currentStroke);
    renderStrokes(currentStroke);
  };
  col.appendChild(nameBtn);

  // Stroke buttons
  STROKES.forEach(sc => {
    const btn = document.createElement('button');
    btn.className = 'stroke-btn' + (sc === currentStroke ? ' active' : '');
    btn.innerText = STROKE_BTN_LABELS[sc];
    btn.onclick = () => {
      window.currentStroke = sc;
      renderTable(sc);
      renderStrokes(sc);
    };
    col.appendChild(btn);
  });
}

document.addEventListener("DOMContentLoaded", async () => {
  await fetchAllData();
  window.currentStroke = STROKES[0];
  renderTable(window.currentStroke);
  renderStrokes(window.currentStroke);
  document.getElementById('deltaModeBtn').onclick = () => {
    deltaMode = (deltaMode === "accomplishments") ? "targets" : "accomplishments";
    renderTable(window.currentStroke);
  };
});
</script>
</body>
</html>
