<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swim Time Progression</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background: #121212; color: #fff; font-family: sans-serif; margin: 0; padding: 2em;}
    .container { max-width: 900px; margin: auto; }
    h1 { margin-bottom: 0.5em; }
    select { font-size: 1em; margin-bottom: 2em; }
    .chart-block { margin-bottom: 48px; background: #232; border-radius: 12px; padding: 18px; box-shadow: 0 4px 16px #0002;}
    canvas { background: #111; border-radius: 8px; }
    .event-label { font-weight: bold; font-size: 1.2em; margin-bottom: 4px; }
    .no-data { color: #aaa; margin-bottom: 2em; }
  </style>
</head>
<body>
<div class="container">
  <h1>Swim Time Progression</h1>
  <label for="swimmer-select"><strong>Swimmer:</strong></label>
  <select id="swimmer-select"></select>
  <div id="charts"></div>
</div>
<script>
// --- Utilities ---
function parseDate(d) {
  if (!d) return new Date(0);
  if (typeof d !== "string") return new Date(d);
  if (d.includes('-')) return new Date(d);
  let [m, d2, y] = d.split('/');
  return new Date(`${y}-${m.padStart(2, '0')}-${d2.padStart(2, '0')}`);
}
function parseTime(t) {
  if (typeof t === "number") return t;
  if (!t) return null;
  t = String(t);
  if (t.includes(':')) {
    let [m, sec] = t.split(':');
    return parseInt(m) * 60 + parseFloat(sec);
  }
  let n = Number(t);
  return isNaN(n) ? null : n;
}
// --- Event parsing ---
function parseEvent(ev) {
  // E.g. "50 FR SCY" or "100 IM SCY"
  let match = ev.match(/^(\d+)\s+([A-Z]+)\s+([A-Z]+)$/);
  if (!match) return null;
  return { dist: match[1], stroke: match[2], fmt: match[3] };
}
function eventKey(dist, stroke, fmt) {
  return `${dist} ${stroke} ${fmt}`;
}
// --- Load all data (async) ---
Promise.all([
  fetch('times.json').then(r => r.json()),
  fetch('b_times_11_12.json').then(r => r.json()),
  fetch('bb_times_11_12.json').then(r => r.json())
]).then(([times, B_TIMES, BB_TIMES]) => {
  // --- Swimmer dropdown setup ---
  const swimmers = Array.from(new Set(times.map(r => r.name)));
  const select = document.getElementById('swimmer-select');
  select.innerHTML = swimmers.map(s =>
    `<option value="${s}">${s}</option>`).join('');
  // Default: Anna
  let defaultSwimmer = "Anna Abdikeeva";
  select.value = swimmers.includes(defaultSwimmer) ? defaultSwimmer : swimmers[0];
  // --- Render function ---
  function renderAllCharts() {
    const swimmer = select.value;
    const chartsDiv = document.getElementById('charts');
    chartsDiv.innerHTML = '';
    // Get this swimmer's times
    const swimmerTimes = times.filter(r => r.name === swimmer);
    // Get all unique events (by distance, stroke, format)
    const eventGroups = {};
    swimmerTimes.forEach(r => {
      let ev = parseEvent(r.event);
      if (!ev) return;
      let key = eventKey(ev.dist, ev.stroke, ev.fmt);
      if (!eventGroups[key]) eventGroups[key] = [];
      eventGroups[key].push(r);
    });
    // For each event, plot chart
    Object.entries(eventGroups).forEach(([evKey, recs]) => {
      // --- Parse data ---
      let { dist, stroke, fmt } = parseEvent(recs[0].event);
      let strokeFull = {
        "FR":"Freestyle","BK":"Backstroke","BR":"Breaststroke","FL":"Butterfly","IM":"IM"
      }[stroke] || stroke;
      let yB = (B_TIMES[strokeFull] && B_TIMES[strokeFull][fmt] && B_TIMES[strokeFull][fmt][dist])
          ? B_TIMES[strokeFull][fmt][dist] : null;
      let yBB = (BB_TIMES[strokeFull] && BB_TIMES[strokeFull][fmt] && BB_TIMES[strokeFull][fmt][dist])
          ? BB_TIMES[strokeFull][fmt][dist] : null;
      // --- Data points ---
      const data = recs.map(r => ({
        x: parseDate(r.date),
        y: parseTime(r.time),
        label: `${r.date} (${r.meet})`,
        meet: r.meet,
        time: r.time
      })).filter(d => d.y !== null && !isNaN(d.y)).sort((a, b) => a.x - b.x);
      // --- Chart block ---
      let chartBlock = document.createElement('div');
      chartBlock.className = "chart-block";
      let evLabel = document.createElement('div');
      evLabel.className = "event-label";
      evLabel.innerText = `${dist} ${stroke} ${fmt}`;
      chartBlock.appendChild(evLabel);
      // --- Canvas ---
      if (data.length === 0) {
        let noData = document.createElement('div');
        noData.className = "no-data";
        noData.innerText = "No data.";
        chartBlock.appendChild(noData);
      } else {
        let canvas = document.createElement('canvas');
        canvas.height = 260;
        chartBlock.appendChild(canvas);
        chartsDiv.appendChild(chartBlock);
        // Chart.js config
        const chart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'Time',
                data: data,
                fill: false,
                borderColor: '#39c570',
                backgroundColor: '#39c570',
                tension: 0.18,
                pointRadius: 5,
                pointHoverRadius: 7
              },
              ...(yB ? [{
                label: 'B Standard',
                data: data.map(d => ({x: d.x, y: yB})),
                borderColor: '#ff3333',
                borderWidth: 1.5,
                borderDash: [4,4],
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0,
                order: 0
              }] : []),
              ...(yBB ? [{
                label: 'BB Standard',
                data: data.map(d => ({x: d.x, y: yBB})),
                borderColor: '#297db9',
                borderWidth: 1.5,
                borderDash: [4,4],
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0,
                order: 0
              }] : [])
            ]
          },
          options: {
            plugins: {
              legend: { labels: { color: "#fff" } },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    let d = ctx.raw;
                    if (typeof d === "object" && d.label)
                      return `${d.label}: ${d.time} sec`;
                    return `${ctx.dataset.label}: ${ctx.formattedValue}`;
                  }
                }
              }
            },
            scales: {
              x: {
                type: "time",
                time: { unit: "month" },
                title: { display: true, text: "Date", color: "#fff" },
                ticks: { color: "#fff" }
              },
              y: {
                title: { display: true, text: "Seconds", color: "#fff" },
                beginAtZero: false,
                ticks: { color: "#fff" }
              }
            }
          }
        });
      }
      chartsDiv.appendChild(chartBlock);
    });
  }
  select.addEventListener('change', renderAllCharts);
  renderAllCharts();
});
</script>
</body>
</html>