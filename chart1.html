<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swim Time Progression</title>
  <meta name="viewport" content="width=500, initial-scale=1">
  <style>
    body { font-family: sans-serif; background: #101112; color: #fff; margin: 0; padding: 1.5em; }
    .controls { margin-bottom: 1.5em; }
    label, select { font-size: 1em; }
    .chart-container { margin-bottom: 2em; background: #16171a; border-radius: 1em; padding: 1em 1.5em 2em 1.5em; box-shadow: 0 2px 12px #000a; }
    h2 { margin-top: 2em; }
    canvas { max-width: 100%; }
  </style>
  <!-- Chart.js Date Adapter! -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Swim Time Progression</h1>
  <div class="controls">
    <label for="swimmer-select"><b>Swimmer:</b></label>
    <select id="swimmer-select"></select>
  </div>
  <div id="charts"></div>

  <script>
    // All your standards and time data (replace URLs as needed)
    const TIMES_URL = "times.json";
    const B_URL = "b_times_11_12.json";
    const BB_URL = "bb_times_11_12.json";

    function parseTimeToSeconds(str) {
      // Accept "1:15.55" or "39.12" (and either string or number input!)
      if (str === null || str === undefined) return null;
      if (typeof str === "number") return str; // Already in seconds (shouldn't be, but handle)
      str = String(str).trim();
      if (str.includes(":")) {
        let [min, sec] = str.split(":");
        return parseInt(min, 10) * 60 + parseFloat(sec);
      }
      if (/^[0-9.]+$/.test(str)) return parseFloat(str);
      return null;
    }

    function parseDateUS(str) {
      // "07/01/2025" -> 2025-07-01
      if (!str) return null;
      if (str.includes('-')) return new Date(str);
      let [m, d, y] = str.split('/');
      return new Date(`${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`);
    }

    async function loadJson(url) {
      const r = await fetch(url);
      return r.json();
    }

    function eventKey(row) {
      // e.g. "50 FR SCY" --> "50 FR SCY"
      return row.event;
    }

    function eventParts(event) {
      // "100 BR LCM" -> {distance, stroke, format}
      const [distance, stroke, format] = event.split(' ');
      return {distance, stroke, format};
    }

    function buildChartData(times, bTimes, bbTimes, event, swimmer) {
      // Filter times for this swimmer and this event type
      let eventRows = times.filter(r => r.name === swimmer && r.event === event);
      if (!eventRows.length) return null;

      // Sort by date ascending
      eventRows.sort((a, b) => parseDateUS(a.date) - parseDateUS(b.date));
      // Data points
      const data = eventRows.map(r => ({
        x: parseDateUS(r.date),
        y: parseTimeToSeconds(r.time),
        label: `${r.date}: ${r.time} (${r.meet})`
      }));

      // Get standards for this event
      let {distance, stroke, format} = eventParts(event);
      let strokeFull = ({
        'FR': 'Freestyle',
        'BK': 'Backstroke',
        'BR': 'Breaststroke',
        'FL': 'Butterfly',
        'IM': 'IM'
      })[stroke];
      // Defensive for standards
      let b = bTimes[strokeFull]?.[format]?.[distance];
      let bb = bbTimes[strokeFull]?.[format]?.[distance];

      // Flat lines for B/BB
      let bLine = b ? {
        label: "B Standard",
        data: data.map(pt => ({x: pt.x, y: b})),
        borderColor: "#5cd677",
        borderDash: [6, 4],
        fill: false,
        pointRadius: 0,
        tension: 0,
        showLine: true,
      } : null;
      let bbLine = bb ? {
        label: "BB Standard",
        data: data.map(pt => ({x: pt.x, y: bb})),
        borderColor: "#20a3dd",
        borderDash: [4, 4],
        fill: false,
        pointRadius: 0,
        tension: 0,
        showLine: true,
      } : null;

      return {
        data,
        bLine, bbLine
      };
    }

    function bestTime(times, event, swimmer) {
      // Get best time for this event
      return times
        .filter(r => r.name === swimmer && r.event === event)
        .map(r => parseTimeToSeconds(r.time))
        .filter(v => v !== null)
        .reduce((best, t) => (best === null || t < best) ? t : best, null);
    }

    async function main() {
      const [times, bTimes, bbTimes] = await Promise.all([
        loadJson(TIMES_URL),
        loadJson(B_URL),
        loadJson(BB_URL)
      ]);
      const swimmers = Array.from(new Set(times.map(r => r.name)));
      const select = document.getElementById("swimmer-select");
      select.innerHTML = swimmers.map(s => `<option>${s}</option>`).join('');
      // Default to Anna if present
      if (swimmers.includes("Anna Abdikeeva")) select.value = "Anna Abdikeeva";

      function renderCharts() {
        const swimmer = select.value;
        const chartsDiv = document.getElementById("charts");
        chartsDiv.innerHTML = "";
        // All events for this swimmer, sorted and unique
        const events = Array.from(new Set(
          times.filter(r => r.name === swimmer).map(r => r.event)
        )).sort();

        events.forEach(event => {
          const chartData = buildChartData(times, bTimes, bbTimes, event, swimmer);
          if (!chartData) return;

          // Title
          const {distance, stroke, format} = eventParts(event);
          let eventTitle = `${distance} ${stroke} (${format})`;

          // Find best time for event for this swimmer
          let best = bestTime(times, event, swimmer);

          // Chart.js needs a unique id per chart
          let canvasId = `chart-${event.replace(/\s/g, '-')}-${Math.random().toString(36).slice(2)}`;
          let container = document.createElement("div");
          container.className = "chart-container";
          container.innerHTML = `<h2>${eventTitle}</h2><canvas id="${canvasId}" height="160"></canvas>`;
          chartsDiv.appendChild(container);

          // Data set: highlight best time point
          const points = chartData.data.map(pt => ({
            ...pt,
            backgroundColor: (pt.y === best) ? "#fbe870" : "#39c570",
            radius: (pt.y === best) ? 7 : 5,
            borderWidth: (pt.y === best) ? 3 : 1,
            borderColor: (pt.y === best) ? "#fbe870" : "#39c570",
          }));

          let datasets = [
            {
              label: "Time",
              data: points,
              borderColor: "#39c570",
              backgroundColor: points.map(pt => pt.backgroundColor),
              showLine: true,
              tension: 0.25,
              fill: false,
              pointRadius: points.map(pt => pt.radius),
              pointBorderWidth: points.map(pt => pt.borderWidth),
              pointBorderColor: points.map(pt => pt.borderColor),
            }
          ];
          if (chartData.bLine) datasets.push(chartData.bLine);
          if (chartData.bbLine) datasets.push(chartData.bbLine);

          // Chart.js chart
          setTimeout(() => {
            new Chart(document.getElementById(canvasId).getContext('2d'), {
              type: 'line',
              data: {
                datasets
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { display: true },
                  tooltip: {
                    callbacks: {
                      label: ctx => {
                        if (ctx.dataset.label === "Time") {
                          let d = ctx.parsed.x;
                          let t = ctx.parsed.y;
                          return `${eventTitle}: ${t}s (${new Date(d).toLocaleDateString()})`;
                        }
                        if (ctx.dataset.label.includes("Standard")) {
                          return `${ctx.dataset.label}: ${ctx.parsed.y}s`;
                        }
                      }
                    }
                  }
                },
                scales: {
                  x: {
                    type: 'time',
                    time: { unit: 'month' },
                    title: { display: true, text: "Date" },
                    grid: { color: "#252628" },
                    adapters: { date: {} }
                  },
                  y: {
                    title: { display: true, text: "Time (s)" },
                    grid: { color: "#252628" },
                  }
                }
              }
            });
          }, 1);
        });
      }

      select.addEventListener("change", renderCharts);
      renderCharts();
    }

    main();
  </script>
</body>
</html>