<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swim Time Progression</title>
  <meta name="viewport" content="width=600, initial-scale=1">
  <style>
    body { background: #fff; color: #222; font-family: system-ui, sans-serif; margin: 0; padding: 0; min-height: 100vh;}
    .container { max-width: 900px; margin: 32px auto; background: #f7f7f7; padding: 24px 12px 32px 12px; border-radius: 16px; box-shadow: 0 4px 20px #0002;}
    select { font-size: 1em; margin-bottom: 1.5em; margin-right: 1em; padding: 0.2em 0.5em;}
    h1 { font-size: 2em; font-weight: 800; margin: 0 0 24px 0; text-align: center;}
    .chart-block { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; margin-bottom: 32px; padding: 24px 18px 10px 18px;}
    .chart-title { font-size: 1.18em; font-weight: 700; text-align: left; margin-bottom: 0.6em; margin-top: 0.2em; color: #1976d2; letter-spacing: 0.04em;}
    @media (max-width: 700px) {
      .container { padding: 5px 0; }
      .chart-block { padding: 8px 0 2px 0; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Swim Time Progression</h1>
    <label for="swimmer-select"><b>Swimmer:</b></label>
    <select id="swimmer-select"></select>
    <div id="charts"></div>
  </div>
  <script>
    function parseDate(str) {
      if (!str) return null;
      if (typeof str !== "string") return null;
      if (str.includes('-')) return new Date(str);
      let [m, d, y] = str.split('/');
      return new Date(`${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`);
    }
    function parseTime(str) {
      if (str == null) return null;
      if (typeof str === "number") return str;
      str = String(str);
      if (str.includes(':')) {
        let [m, s] = str.split(':');
        return parseInt(m) * 60 + parseFloat(s);
      }
      return parseFloat(str);
    }
    function fmtSwimTime(t, orig) {
      if (orig && typeof orig === "string" && orig.includes(':')) return orig;
      if (typeof t === "number" && !isNaN(t)) return t.toFixed(2);
      return orig;
    }
    // Tooltip logic
    function getTooltipLines(ctx) {
      const pt = ctx.raw;
      if (!pt || !pt.raw) return [];
      const r = pt.raw;
      const lines = [];
      lines.push(`Date: ${r.date}`);
      lines.push(`Time: ${fmtSwimTime(pt.y, r.time)} sec`);
      lines.push(`Meet: ${r.meet}`);
      if (r.time_standard) lines.push(`Standard: ${r.time_standard}`);
      // Delta to B/BB logic:
      const v = parseTime(pt.y);
      const b = parseTime(pt.b);
      const bb = parseTime(pt.bb);
      // If both exist, show both if relevant
      if (isFinite(b) && v > b) {
        lines.push(`Δ to B: ${(v - b).toFixed(2)} sec`);
      } else if (isFinite(b)) {
        lines.push(`Δ to B: 0.00 sec`);
        if (isFinite(bb)) {
          if (v > bb) {
            lines.push(`Δ to BB: ${(v - bb).toFixed(2)} sec`);
          } else {
            lines.push(`Δ to BB: 0.00 sec`);
          }
        }
      } else if (isFinite(bb)) {
        if (v > bb) {
          lines.push(`Δ to BB: ${(v - bb).toFixed(2)} sec`);
        } else {
          lines.push(`Δ to BB: 0.00 sec`);
        }
      }
      return lines;
    }

    let swimmerData, bTimes, bbTimes;
    Promise.all([
      fetch('times.json').then(r=>r.json()),
      fetch('b_times_11_12.json').then(r=>r.json()),
      fetch('bb_times_11_12.json').then(r=>r.json()),
    ]).then(([times, b, bb]) => {
      swimmerData = times;
      bTimes = b;
      bbTimes = bb;
      setupPage();
    });

    function getEventParts(evStr) {
      // e.g. "100 BR LCM"
      let m = evStr.match(/^(\d+)\s+([A-Z]+)\s+([A-Z]+)$/);
      if (!m) return {};
      return { dist: m[1], stroke: m[2], fmt: m[3] };
    }
    function getStandards(stroke, fmt, dist) {
      const stFull = {
        "FR": "Freestyle",
        "BK": "Backstroke",
        "BR": "Breaststroke",
        "FL": "Butterfly",
        "IM": "IM"
      }[stroke] || stroke;
      // always look up string keys!
      return {
        b: bTimes?.[stFull]?.[fmt]?.[String(dist)] ?? null,
        bb: bbTimes?.[stFull]?.[fmt]?.[String(dist)] ?? null
      }
    }

    function setupPage() {
      const swimmers = Array.from(new Set(swimmerData.map(r => r.name))).sort();
      const select = document.getElementById('swimmer-select');
      select.innerHTML = swimmers.map(s => `<option value="${s}">${s}</option>`).join('');
      select.value = swimmers[0];
      select.onchange = () => renderCharts(select.value);
      renderCharts(select.value);
    }

    function renderCharts(swimmerName) {
      const byEvent = {};
      swimmerData.filter(r => r.name === swimmerName).forEach(r => {
        let {dist, stroke, fmt} = getEventParts(r.event);
        if (!(dist && stroke && fmt)) return;
        const key = `${dist} ${stroke} ${fmt}`;
        if (!byEvent[key]) byEvent[key] = [];
        const standards = getStandards(stroke, fmt, dist);
        byEvent[key].push({
          ...r,
          dateX: parseDate(r.date),
          y: parseTime(r.time),
          b: standards.b,
          bb: standards.bb
        });
      });
      // Clear charts
      const chartsDiv = document.getElementById('charts');
      chartsDiv.innerHTML = '';

      Object.entries(byEvent).forEach(([ev, arr], idx) => {
        arr.sort((a, b) => a.dateX - b.dateX);
        const dataPoints = arr.map(r => ({
          x: r.dateX, y: r.y, raw: r, b: r.b, bb: r.bb
        }));

        // Recompute B/BB for THIS event, as a float, only if present and finite
        let any = arr[0];
        let yB = (any && isFinite(parseTime(any.b))) ? parseTime(any.b) : null;
        let yBB = (any && isFinite(parseTime(any.bb))) ? parseTime(any.bb) : null;

        // Only draw standards if value is meaningful (> 0, < Infinity)
        const block = document.createElement('div');
        block.className = 'chart-block';
        block.innerHTML = `<div class="chart-title">${ev}</div><canvas id="chart${idx}" height="220"></canvas>`;
        chartsDiv.appendChild(block);
        new Chart(block.querySelector('canvas').getContext('2d'), {
          type: 'line',
          data: {
            datasets: [
              {
                label: swimmerName,
                data: dataPoints,
                borderColor: '#1976d2',
                backgroundColor: '#8ec9f8',
                pointRadius: 5,
                pointHoverRadius: 7,
                tension: 0.17,
                fill: false
              },
              ...(yB ? [{
                label: "B Standard",
                data: dataPoints.map(p => ({x:p.x, y:yB})),
                borderColor: '#53cb67',
                borderDash: [8, 6],
                pointRadius: 0,
                borderWidth: 2,
                fill: false
              }] : []),
              ...(yBB ? [{
                label: "BB Standard",
                data: dataPoints.map(p => ({x:p.x, y:yBB})),
                borderColor: '#f5a623',
                borderDash: [3, 5],
                pointRadius: 0,
                borderWidth: 2,
                fill: false
              }] : [])
            ]
          },
          options: {
            plugins: {
              legend: { display: true, position: "top" },
              tooltip: {
                callbacks: {
                  label: function(ctx) {
                    if (ctx.datasetIndex === 0) {
                      // Show as array to force multi-line tooltip
                      return getTooltipLines(ctx);
                    }
                    // Standard lines show single label
                    return `${ctx.dataset.label}: ${ctx.parsed.y}`;
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: { unit: 'day', tooltipFormat: 'M/d/yy', displayFormats: { day: 'M/d/yy' } },
                title: { display: true, text: 'Date', font: { weight: 'bold'} },
                grid: { color: '#f0f0f0' }
              },
              y: {
                beginAtZero: false,
                title: { display: true, text: 'Time (sec)', font: { weight: 'bold'} },
                grid: { color: '#f0f0f0' }
              }
            }
          }
        });
      });
    }
  </script>
</body>
</html>
