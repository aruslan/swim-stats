<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swim Progression Chart</title>
  <meta name="viewport" content="width=600, initial-scale=1">
  <style>
    body { background: #fff; color: #222; font-family: system-ui, sans-serif; margin: 0; padding: 0; min-height: 100vh;}
    .container { max-width: 900px; margin: 32px auto; background: #f7f7f7; padding: 24px 16px 32px 16px; border-radius: 16px; box-shadow: 0 4px 20px #0002;}
    select { font-size: 1em; margin-bottom: 1.5em; margin-right: 1em; padding: 0.2em 0.5em;}
    h1 { font-size: 2em; font-weight: 800; margin: 0 0 24px 0; text-align: center;}
    .chart-block { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; margin-bottom: 28px; padding: 20px 10px 10px 10px;}
    .chart-title { font-size: 1.15em; font-weight: 700; text-align: left; margin-bottom: 0.5em; margin-top: 0.2em; color: #1976d2; letter-spacing: 0.04em;}
    @media (max-width: 700px) {
      .container { padding: 8px 2px; }
      .chart-block { padding: 8px 0 2px 0; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Swim Time Progression</h1>
    <label for="swimmer-select"><b>Swimmer:</b></label>
    <select id="swimmer-select"></select>
    <div id="charts"></div>
  </div>
  <script>
    // Utility functions
    function parseDate(str) {
      if (!str) return null;
      if (typeof str !== "string") return null;
      if (str.includes('-')) return new Date(str);
      let [m, d, y] = str.split('/');
      return new Date(`${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`);
    }
    function parseTime(str) {
      if (str == null) return null;
      if (typeof str === "number") return str;
      str = String(str);
      if (str.includes(':')) {
        let [m, s] = str.split(':');
        return parseInt(m)*60 + parseFloat(s);
      }
      return parseFloat(str);
    }
    function fmtSwimTime(seconds, orig) {
      if (!isFinite(seconds) || seconds == null) return orig || "";
      // Show MM:SS.ss if >=60s, else SS.ss
      if (seconds >= 60) {
        let m = Math.floor(seconds / 60);
        let s = (seconds - m*60).toFixed(2).padStart(5, "0");
        return `${m}:${s}`;
      }
      return seconds.toFixed(2);
    }

    // Data
    const TIMES_URL = "times.json";
    const B_URL = "b_times_11_12.json";
    const BB_URL = "bb_times_11_12.json";
    const STROKE_LABELS = { "FR": "Freestyle", "BK": "Backstroke", "BR": "Breaststroke", "FL": "Butterfly", "IM": "IM" };
    function eventDetails(eventStr) {
      const m = eventStr.match(/^(\d+)\s+([A-Z]+)\s+([A-Z]+)$/);
      if (!m) return null;
      return { distance: m[1], stroke: m[2], format: m[3] };
    }

    let charts = [];

    Promise.all([
      fetch(TIMES_URL).then(r => r.json()),
      fetch(B_URL).then(r => r.json()),
      fetch(BB_URL).then(r => r.json())
    ]).then(([data, bTimes, bbTimes]) => {
      // 1. Swimmer selector
      const swimmers = Array.from(new Set(data.map(r => r.name))).sort();
      const select = document.getElementById('swimmer-select');
      select.innerHTML = swimmers.map(s => `<option value="${s}">${s}</option>`).join('');
      const defaultSwimmer = swimmers.find(s => s.toLowerCase().includes("anna")) || swimmers[0];
      select.value = defaultSwimmer;

      // Allow URL param ?swimmer=Name
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('swimmer')) {
        let val = decodeURIComponent(urlParams.get('swimmer'));
        if (swimmers.includes(val)) select.value = val;
      }

      select.onchange = () => renderCharts(select.value);
      renderCharts(select.value);

      function renderCharts(swimmer) {
        charts.forEach(ch => ch.destroy && ch.destroy());
        charts = [];
        const el = document.getElementById('charts');
        el.innerHTML = "";

        // Get all events for this swimmer, grouped by event
        const records = data.filter(r => r.name === swimmer);
        const events = {};
        for (let rec of records) {
          if (!events[rec.event]) events[rec.event] = [];
          events[rec.event].push(rec);
        }
        // Sort events alphabetically by event string
        const eventKeys = Object.keys(events).sort((a, b) => {
          let pa = eventDetails(a), pb = eventDetails(b);
          if (pa && pb) {
            if (pa.stroke !== pb.stroke) return pa.stroke.localeCompare(pb.stroke);
            if (parseInt(pa.distance) !== parseInt(pb.distance)) return parseInt(pa.distance) - parseInt(pb.distance);
            return pa.format.localeCompare(pb.format);
          }
          return a.localeCompare(b);
        });

        for (let eventStr of eventKeys) {
          const rawSeries = events[eventStr].sort((a, b) => parseDate(a.date) - parseDate(b.date));
          // Find event details and B/BB
          let ev = eventDetails(eventStr);
          let yB = null, yBB = null;
          if (ev && bTimes && bbTimes) {
            yB = bTimes[STROKE_LABELS[ev.stroke]]?.[ev.format]?.[ev.distance];
            yBB = bbTimes[STROKE_LABELS[ev.stroke]]?.[ev.format]?.[ev.distance];
          }

          const series = rawSeries
            .map(r => ({
              x: parseDate(r.date),
              y: parseTime(r.time),
              raw: r,
              b: yB, bb: yBB
            }))
            .filter(p => p.x && isFinite(p.y));

          if (!series.length) continue;

          // Compose chart
          const chartTitle = `${ev ? ev.distance : ''} ${ev ? STROKE_LABELS[ev.stroke] : eventStr} ${ev ? ev.format : ''}`.replace(/\s+/, ' ').trim();

          const div = document.createElement('div');
          div.className = "chart-block";
          const title = document.createElement('div');
          title.className = "chart-title";
          title.textContent = chartTitle;
          div.appendChild(title);
          const canvas = document.createElement('canvas');
          div.appendChild(canvas);
          el.appendChild(div);

          // Datasets
          const datasets = [
            {
              label: "Swim time",
              data: series,
              borderColor: "#1976d2",
              backgroundColor: "rgba(25,118,210,0.15)",
              pointBackgroundColor: "#1976d2",
              pointRadius: 4,
              pointHoverRadius: 6,
              tension: 0.2,
              fill: false
            }
          ];
          if (yB) datasets.push({
            label: "B Standard",
            data: series.map(pt => ({x: pt.x, y: parseTime(yB)})),
            borderColor: "#39c570",
            borderDash: [6,3],
            pointRadius: 0,
            fill: false
          });
          if (yBB) datasets.push({
            label: "BB Standard",
            data: series.map(pt => ({x: pt.x, y: parseTime(yBB)})),
            borderColor: "#ffb600",
            borderDash: [4,2],
            pointRadius: 0,
            fill: false
          });

          // Tooltip callback
          function getTooltipLines(ctx) {
            // Only for data points
            const pt = ctx.raw;
            if (!pt || !pt.raw) return [];
            const r = pt.raw;
            const lines = [];
            lines.push(`Date: ${r.date}`);
            lines.push(`Time: ${fmtSwimTime(pt.y, r.time)} sec`);
            lines.push(`Meet: ${r.meet}`);
            if (r.time_standard) lines.push(`Standard: ${r.time_standard}`);
            // Deltas
            const v = pt.y;
            const b = parseTime(pt.b);
            const bb = parseTime(pt.bb);
            if (b || bb) {
              if (bb && isFinite(bb)) {
                if (v > bb) lines.push(`Δ to BB: +${(v-bb).toFixed(2)} sec`);
                else lines.push(`At or above BB!`);
              }
              if (b && isFinite(b)) {
                if (v > b) lines.push(`Δ to B: +${(v-b).toFixed(2)} sec`);
                else if (v > bb) lines.push(`At or above B!`);
              }
            }
            return lines;
          }

          // Create chart
          charts.push(new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              aspectRatio: 1.9,
              plugins: {
                legend: { position: 'top', labels: { color: "#222", font: { size: 13, weight: 'bold' } } },
                title: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      // Only show tooltip for swim times (dots), not B/BB lines
                      if (context.dataset.label !== "Swim time") return false;
                      // Compose custom tooltip for point
                      return getTooltipLines(context).join('\n');
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: {
                      day: 'M/d/yy',
                      month: 'M/yy',
                      year: 'yy'
                    },
                    tooltipFormat: 'M/d/yy'
                  },
                  title: { display: true, text: 'Date', color: '#222' },
                  ticks: { color: '#222', autoSkip: false, maxRotation: 45, minRotation: 0 }
                },
                y: {
                  title: { display: true, text: 'Time (seconds)', color: '#222' },
                  ticks: { color: '#222' }
                }
              }
            }
          }));
        }
      }
    });
  </script>
</body>
</html>
